28 Aug 2022
The point of this section is to provide an overview of C++
without going into too much detail. 
Other than the most basic language facilities we will hear
about structures, classes, and enumerations. 
He'll talk a bit a bout separate compilation, namespaces, 
and error handling. 

- Model of memory and computation, along with other basic facilities. Chapter discusses the 
aspects of the language that support 'procedural' programming. 

- Gives an overview of the entire language, does not talk about the differences in C, C++98, 
or what's new in C++11

2.2 The compilation process has several steps
1) The preprocessor processes the file and deals with all # directives. Includes, Define, and
preprocessor macros, etc. I ran 'clang -E example.cpp' and it appended what looks like the 
entirely of the header file (27000~ lines) the top of my .cpp file. File was 735K
2) The compiler compiles everything down to a binary object file (.o) that the linker then
links together. I ran 'clang -c example.cpp' and it output example.o. File was 2.6K Clearly 
it reduces the file size. I also ran the proprocessor against the minimal program and it just 
added a handfull of line that look preprocessor directives themselves (?).
3) The linkers job is to take all the object files and 'link' them into an executable binary. 

For g++ you can specifify the standard you want to compile by using -std=C++20, or whatever
standard you want to use. 

{} represents grouping in C++

<< writes it's second arg (right) onto it's first (left)

return type 'void' indicates that that function does not return a value 

2.2.2 
A Type definesa set of possible values for and a set of operations.
An Object is some memory that holds a value of some type.
A Value is set of bits interpretted according to a type.
A Variable is a named object.

C++ provides several fundamental types including bool, char, int, double which coorespond 
directly to hardware facilities and which have a fixed size measured in bytes. These types
are implementation defined, which means a char doesn't always have to be an 8 bit bytes on 
every system. 

{} list initialization does NOT allow narrowing. You can also do ={} where you're 
reassigning to an already initialized value. 

If you try to initialize a value with a type that would result in truncation with {}, it'll
throw a fit. Unless you use static_cast<T>(value) it'll raise an error and won't compile. 
Needing to use a static_cast<> indicates a design error. Theres not a great reason to 
cast a double as an int, etc. 

const is mainly used for specifying interfaces and protecting data when passing into functions
this seems to be more of a compiler time check because if you pass into a reference to something
and declare it as a const in the function signature, then the program won't compile if you try
to change the data (ie. *reference = new value) or something similar. seems to just be another 
layer of the static type checking system

not 100% sure about the differences between " " and ' '. 
'A' is a char literal. 
"ABC" is a string literal which is an array of char
You can't compare 'A' to "B" with == because there isn't a conversion that makes sense. 
"a" is a char array and returns a pointer to first element 
ie. const char*, *"a" gives you 'a'

Pointers, Arrays, and Loops. 
The size of an array must be a constant expression.

& is the address of operator
you can use this in range-for statements to pass by ref instead of by copy 
a reference cannot be made to refer to a different object after initialization 

You should check your pointers to make sure they point at what they're supposed to point at. 
C-style string are 0 terminated. Something like this 'this is a string\0' and you know you've gone past the last char when you find \0;
In order code, 0 or NULL is usually used instead of nullptr. nullptr avoids confusion between 0 and NULL. 

I think that I understand everything that has been presented so far. I'm trying to take it slow and really work through all the examples so that later on I don't 
get caught flat footed. 

2.3 User defines types























